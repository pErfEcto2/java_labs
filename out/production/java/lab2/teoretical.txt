TASK 2

Метод nextInt() в классе Scanner = Не является ни методом доступа, ни модифицирующим методом . Это метод, который считывает данные из источника (например, потока ввода) и преобразует их в целое число. Он не предоставляет доступ к состоянию объекта (Scanner) и не изменяет его внутреннее состояние напрямую (кроме продвижения позиции чтения).

Метод nextInt() в классе Random - модифицирующий 






TASK 3

Да
public class Counter {
    private int count;

    // Модифицирующий метод, который увеличивает счетчик и возвращает новое значение
    public int increment() {
        return ++count; // Изменяет состояние и возвращает новое значение
    }
}

Можно ли создать метод доступа с возвращаемым типом void?  

Нет, метод доступа не может иметь тип возвращаемого значения void. По определению, метод доступа (getter) предоставляет доступ к значению какого-либо поля объекта, а значит он должен возвращать это значение. Если метод ничего не возвращает (void), то он не может быть методом доступа









TASK 4

В Java примитивные типы данных (например, int) передаются в метод по значению , а не по ссылке. Это означает, что при передаче примитивных переменных в метод создается копия их значений, и изменения внутри метода применяются только к этим копиям, не затрагивая оригинальные переменные

Можно ли поменять местами содержимое двух объектов типа Integer?  

Тип Integer в Java является неизменяемым  (immutable). Это означает, что после создания объекта Integer его значение нельзя изменить. Если вы попытаетесь "поменять местами" два объекта Integer, вы фактически будете менять ссылки на объекты, но сами объекты останутся неизменными








TASK 8

Да
IntelliJ IDEA предоставляет множество инструментов для автоматизации: 

    Live Templates : Позволяет создавать собственные или использовать готовые шаблоны кода. Например:
        sout → System.out.println();
        fori → for (int i = 0; i < ; i++) { }
        Можно настроить свои шаблоны для часто используемого кода.
         
    Generate Code (Alt+Insert) : Генерация конструкторов, геттеров/сеттеров, методов toString, equals, hashCode, реализации интерфейсов и т.д.
    Postfix Completion : Автоматическое завершение выражений. Например:
        variable.for → for (Item item : variable) { }
        variable.null → if (variable == null) { }
         
    Refactorings : Автоматическое рефакторинг кода, включая переименование, извлечение методов, изменение сигнатуры и т.д.
     
	 
	 
	 
	 
	 





TASK 16

Да, вложенный класс Node должен быть статическим , если он используется для хранения элементов очереди и не требует доступа к экземпляру внешнего класса Queue. 
Обоснование: 

    Связный список и независимость узлов : 
        Узел (Node) в связном списке представляет собой самостоятельную сущность, которая содержит данные (в данном случае строку) и ссылку на следующий узел.
        Узлам не требуется доступ к полям или методам внешнего класса Queue. Они просто хранят данные и ссылки









TASK 17

Если итератор реализован так, как показано в вашем коде, то класс Iterator не должен быть статическим , потому что он напрямую зависит от состояния внешнего класса Queue